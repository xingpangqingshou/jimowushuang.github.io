<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>两个字符串的最长公共子序列问题-从暴力递归到动态规划优化</title>
      <link href="/2022/06/09/wypwww/"/>
      <url>/2022/06/09/wypwww/</url>
      
        <content type="html"><![CDATA[<p>动态规划问题的最终解是找到转移方程，但是转移方程很多时候并不是那么好找的。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个字符串寻找最长公共子序列。例如”ab1c2de3f”和”x1y2z3”的最长子序列为”123”</p><h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><p>暴力递归的解决思路是很容易想到的。<br>递归函数返回两个字符串 str1，str2 到 index1，index2 位置的最长公共子序列的长度。<br>递归终止的条件是两个串中任意一个串是空串，那么最长公共子序列的长度为 0。<br>到任意一个 index1，index2 位置有以下几种可能性</p><ul><li>最长公共子序列的最后一个值和 str1[index1] 、str2[index2]都相同。</li><li>最长公共子序列的最后一个值和 str1[index1] 、str2[index2]都不相同。</li><li>最长公共子序列的最后一个值和 str1[index1] 、str2[index2]其中一个相同。</li></ul><p>这样就把问题拆分成了子问题，使用递归求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> process(text1.toCharArray(),text1.length() - <span class="number">1</span>,text2.toCharArray(),text2.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] str1, <span class="type">int</span> index1, <span class="type">char</span>[] str2, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index2 &lt; <span class="number">0</span> || index1 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str1[index1] == str2[index2])&#123;</span><br><span class="line">            <span class="keyword">return</span> process(str1,index1 -<span class="number">1</span> ,str2, index2 -<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(str1,index1,str2,index2 - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> process(str1,index1 - <span class="number">1</span>,str2,index2);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> process(str1,index1 - <span class="number">1</span>,str2,index2 - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> Math.max(Math.max(p1,p2),p3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是递归里面会进行很多次的重复计算，通常而言对于动态规划问题，暴力递归一般会超时。</p><h2 id="缓存优化记忆化搜索"><a href="#缓存优化记忆化搜索" class="headerlink" title="缓存优化记忆化搜索"></a>缓存优化记忆化搜索</h2><p>对于上述递归过程，其实会有很多重复的求解过程。<br>把重复的解放到一个缓存里面，每次直接从缓存中取值，这样就可以减少很多的重复过程。<br>新建 db 数组(当然 map 也可以)，作为缓存数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> db[][];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line"></span><br><span class="line">        db = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length()][text2.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; text1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; text2.length();j++)&#123;</span><br><span class="line">                db[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> process(text1.toCharArray(),text1.length() - <span class="number">1</span>,text2.toCharArray(),text2.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] str1, <span class="type">int</span> index1, <span class="type">char</span>[] str2, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index2 &lt; <span class="number">0</span> || index1 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(db[index1][index2] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> db[index1][index2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str1[index1] == str2[index2])&#123;</span><br><span class="line">            db[index1][index2] = process(str1,index1 -<span class="number">1</span> ,str2, index2 -<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> db[index1][index2];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(str1,index1,str2,index2 - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> process(str1,index1 - <span class="number">1</span>,str2,index2);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> process(str1,index1 - <span class="number">1</span>,str2,index2 - <span class="number">1</span>);</span><br><span class="line">            db[index1][index2] = Math.max(Math.max(p1,p2),p3);</span><br><span class="line">            <span class="keyword">return</span> db[index1][index2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>上述的记忆化搜索已经可以 AC 了。看着上述的记忆化搜索的过程其实也比较容易推导出来动画规划的的转移方程了。其实从 0 开始直接构建上述的缓存 db 数组的过程就是动态规划的转移方程。把缓存想象成二位表，而转移方程就是构建二位表的过程。<br>PS：这里为了简化判断流程给二位表 db 多套了一层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] str1 = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] db = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= text1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= text2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1[i-<span class="number">1</span>] == str2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    db[i][j] = db[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> db[i][j-<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> db[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> db[i-<span class="number">1</span>][j];</span><br><span class="line">                    db[i][j] = Math.max(Math.max(p1,p2),p3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> db[text1.length()][text2.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 暴力递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>炉石佣兵全自动脚本</title>
      <link href="/2022/06/09/va6ick/"/>
      <url>/2022/06/09/va6ick/</url>
      
        <content type="html"><![CDATA[<p>本插件为全自动佣兵插件，目标做到全自动，自动练级，自动做任务，自动升级，自动换佣兵。</p><h2 id="特别声明"><a href="#特别声明" class="headerlink" title="特别声明"></a>特别声明</h2><p>本插件为学习 C#所制，免费使用，不可用于盈利目的。在你下载了该插件之后代表你同意本声明</p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>下载<a href="https://codeload.github.com/jimowushuang/hs-mercenary/zip/refs/heads/main">最新的版本</a> 解压放到炉石根目录。 打开炉石自动推门进入证明插件安装成功。<br>插件默认会使用名称为 PVE 的队伍，会自动刷 2-5 这个图，会自动选择距离神秘人最近的路径，会自动根据当前任务更换佣兵，自动做任务，佣兵满级会自动更换未满级的佣兵，当然这些逻辑都可以修改，详见配置列表</p><h2 id="配置列表"><a href="#配置列表" class="headerlink" title="配置列表"></a>配置列表</h2><table><thead><tr><th><strong>配置项</strong></th><th><strong>说明</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>使用的队伍名称</td><td>刷图使用的队伍名称</td><td>PVE</td></tr><tr><td>要刷的地图</td><td>要刷的地图</td><td>2-5</td></tr><tr><td>自动升级技能</td><td>开启之后如果可以升级技能会自动升级</td><td>true</td></tr><tr><td>自动制作佣兵</td><td>开启之后如果硬币足够会自动制作新佣兵</td><td>true</td></tr><tr><td>刷图模式</td><td>0: 刷图 1: 刷神秘人 2: 自动做任务</td><td>0</td></tr><tr><td>队伍人数</td><td>队伍认识不够的时候插件会自动填充队伍人数</td><td>6</td></tr><tr><td>核心队伍人数</td><td>前 n 个核心队伍人数不会被自动更换</td><td>0</td></tr></tbody></table><h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><p><a href="https://github.com/jimowushuang/hs-control/releases/tag/v1.0.0">炉石监控程序</a> 可以在炉石异常退出的时候重启炉石</p><h2 id="交流群"><a href="#交流群" class="headerlink" title="交流群"></a>交流群</h2><p>QQ 群: 792054397</p>]]></content>
      
      
      
        <tags>
            
            <tag> 炉石传说 </tag>
            
            <tag> 辅助 </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的问题模版</title>
      <link href="/2022/06/01/ritgwn/"/>
      <url>/2022/06/01/ritgwn/</url>
      
        <content type="html"><![CDATA[<p>有关图的问题算法一般不是很复杂，难点一般在于数据结构，一张图可以用很多种的数据结构表达出来，相对应的同一种算法在不同的数据结构下面就有不同的表现。因此对于图问题有一个自己顺手的数据结构是很有必要的。当遇到不是自己顺手的数据结构可以手写转换器转换成自己熟悉的数据结构。<br>以下是个人顺手的数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.in = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.out = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node from;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> weight, Node&lt;T&gt; from, Node&lt;T&gt; to)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Integer,Node&gt; nodes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">()</span> &#123;</span><br><span class="line">        nodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于模版，实现图的算法</p><h2 id="广度优先遍历-bfs"><a href="#广度优先遍历-bfs" class="headerlink" title="广度优先遍历 bfs"></a>广度优先遍历 bfs</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    queue.add(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        <span class="keyword">for</span>(Node next: cur.next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(next))&#123;</span><br><span class="line">                queue.add(next);</span><br><span class="line">                set.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度优先遍历-dfs"><a href="#深度优先遍历-dfs" class="headerlink" title="深度优先遍历 dfs"></a>深度优先遍历 dfs</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    stack.add(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    System.out.println(node.value);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">for</span>(Node next: cur.next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(next))&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                stack.push(next);</span><br><span class="line">                set.add(next);</span><br><span class="line">                System.out.println(next.value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
